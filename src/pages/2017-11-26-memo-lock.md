---
title: 关于乐观锁和悲观锁的笔记
subtitle: 乐观锁和悲观锁的概念，暂且做个笔记。
date: 2017-11-26 21:53:35 +8
tags:
  - SQL
  - Database
---

### 惯例，先来几句废话

边记录博客边实践确实太慢了。

想了想还是先把重要的点摘录一下以后深究，现阶段还是专心的实践吧。（所以博客这边更新速度就会慢很多了）

嗯，实践的效率还是挺高的。底层 Mapper 基本要搞定了。

回到正题。

### 绕不开的话题，并发

并发是一个应用不可避免的话题，有用户有操作就存在并发。

比如一篇文章的点赞数，评论的点赞数，点击量，等等。

我们要将这些数据正确无误的更新到数据库里的话，就需要制定合适的并发策略。

数据库层面我们需要考虑使用什么锁来处理并发的数据保存。

我们需要选择使用乐观锁还是悲观锁。

### 什么是乐观锁？什么是悲观锁？

方便理解，我们先说悲观锁。

悲观锁（Pessimistic Lock）是数据库的一项功能。通过`select...for update`的形式获得悲观锁，在这个事务提交之后释放锁。

获得悲观锁的事务未提交之前，其他事务无法查询被锁住的数据。

这里有一个点需要注意，获得悲观锁时如果使用了索引（如指定主键）的情况获得的是行锁，即其他事务还可以访问同一个表的其他数据。相反，如果获得悲观锁时没有使用索引，将获得表锁，即其他事务将不能访问这张表。

为了减少影响提高效率，应该尽量使用索引。

悲观锁类似于 synchronized 关键字。

一个事务将要更新一条数据时，先宣布“我要修改它！”，其他事务这时也需要修改同样的数据，但是后来者看到这个宣言就默默的等第一个事务结束，然后再做出同样的宣言，让其后的事务等待。

坏处也很明显，在数据库层多了加锁和解锁两个步骤，一定程度消耗了资源降低了效率。

以上就是悲观锁，而乐观锁并不是数据库的功能。

乐观锁（Optimistic Lock）是一种思路，不像悲观锁堵塞线程，乐观锁乐观的认为目标数据每一次都没有被修改，所以只再更新的步骤匹配一次元数据。

通常是在表里加一个版本字段，或者时间戳，每次更新的时候匹配一次是否符合预期，否则就不执行更新。

或者在更新点赞数的场合，我选择每次匹配更新前的数据是否与之前 check 时一致，否则就不执行更新。

乐观锁没有加锁与解锁的步骤，但是如果修改的对象被修改，根据不同的场合可能会增加读写量。

### 乐观锁与悲观锁的应用场景

我做了一个简单测试，使用乐观锁和悲观锁进行点赞数的累加测试。发现在并发量没有达到一定规模的时候区别并不大。

点赞数从 0 累加到 100 和从 0 累加到 1000 的测试中，乐观锁和悲观锁的效率相差无几。但是从读写量上来看明显乐观锁远多于悲观锁，这取决于并发的每个请求的间隔时间。

而当点赞数从 0 累加到 10000 时，乐观锁由于并发量的激增导致重复读写量也大幅上升，乐观锁使用了悲观锁两倍的时间才完成累加操作。

通过测试结果可以看出，悲观锁适合并发量中上且集中的场合，可以有效的控制读写量并正确的将数据持久化到数据库。

而乐观锁适合并发量中等以下且相对间隔较长的场合，请求越分散效率越高。

### 结束

这也就是记了一个点，留待以后深究。

以上。
